---
import { getCollection } from 'astro:content';

// Props para poder reutilizar el componente
interface Props {
  showSelector?: boolean; // por defecto true (index.astro)
  slug?: string;          // p.ej. "baja-gimnasio" en la p치gina de slug
}

const { showSelector = true, slug } = Astro.props as Props;

// 1) Cargamos todas las cartas de la colecci칩n "cartas"
const entries = await getCollection('cartas', ({ data }) => data.activo !== false);

// 2) Funci칩n para convertir {nombre_completo} -> "Nombre Completo"
const labelOverrides: Record<string, string> = {
  codigo_postal: 'C칩digo Postal',
  dni_nie: 'DNI/NIE',
};

function humanizePlaceholder(name: string): string {
  if (labelOverrides[name]) return labelOverrides[name];

  return name
    .split('_')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

// 3) Construimos la estructura de datos que enviaremos al cliente
type FieldDef = {
  name: string;
  label: string;
};

type CartaDef = {
  id: string;
  titulo: string;
  body: string;
  fields: FieldDef[];
  hasFirma: boolean;
};

const cartas: CartaDef[] = entries.map((entry) => {
  const body = entry.body;

  // Extraemos todos los {placeholders} 칰nicos
  const matches = Array.from(body.matchAll(/\{([a-zA-Z0-9_]+)\}/g));
  const uniqueNames = Array.from(new Set(matches.map((m) => m[1])));

  const hasFirma = uniqueNames.includes('firma');

  const fields: FieldDef[] = uniqueNames
    .filter((name) => name !== 'firma') // 游녣 no creamos campo de texto para {firma}
    .map((name) => ({
    name,
    label: humanizePlaceholder(name),
  }));

  return {
    id: entry.id,
    titulo: entry.data.titulo,
    body,
    fields,
    hasFirma,
  };
});

// Carta inicial
let initialCartaId = cartas[0]?.id ?? '';

// Si nos pasan un slug (p.ej. en la p치gina /cartas/[slug]), lo usamos
if (slug) {
  const matchingEntry = entries.find(
    (entry) =>
      entry.data.slug === slug ||
      entry.data.clave === slug ||
      entry.slug === slug
  );
  if (matchingEntry) {
    initialCartaId = matchingEntry.id;
  }
}

// 쯄ostramos el selector de tipo de carta?
// En el index queremos verlo SIEMPRE que showSelector sea true,
// aunque solo haya una carta disponible.
const showSelect = showSelector;
---

{cartas.length === 0 ? (
  <section class="cr-generator" id="generador">
    <div class="cr-container">
      <p>
        No hay cartas configuradas en la colecci칩n <code>cartas</code>.
      </p>
    </div>
  </section>
) : (
  <section class="cr-generator" id="generador">
    <div class="cr-container">
      <div class="cr-generator__grid" data-cr-generator>
        {/* Columna izquierda: formulario */}
        <div class={`cr-generator__form ${showSelect ? '' : 'cr-generator__form--no-select'}`}>
          {/* Selector de tipo de carta (se puede ocultar por CSS cuando showSelect = false) */}
          <div class="cr-field cr-field--select">
            <label class="cr-field__label">
              <span>Tipo de carta</span>
              <select data-cr-template>
                {/* Las opciones se rellenan por JS para mantener una sola fuente de verdad */}
              </select>
            </label>
          </div>

          <div class="cr-generator__fields" data-cr-fields>
            {/* Aqu칤 JS inyecta los campos seg칰n los {placeholders} */}
          </div>

          {/* 츼rea especial de firma (solo se muestra si la carta tiene {firma}) */}
          <div class="cr-signature" data-cr-signature hidden>
            <span class="cr-signature__label">Firma</span>
            <canvas
              class="cr-signature__canvas"
              width="400"
              height="160"
            ></canvas>
            <div class="cr-signature__actions">
              <button
                type="button"
                class="cr-button cr-button--ghost"
                data-cr-signature-clear
              >
                Limpiar firma
              </button>
            </div>
          </div>

          <div class="cr-generator__actions">
            <button class="cr-button cr-button--primary" data-cr-generate>
              Generar
            </button>
            <button class="cr-button cr-button--ghost" data-cr-reset>
              Limpiar
            </button>
          </div>

          <p class="cr-generator__hint">
            Consejo: usa correo certificado o registro electr칩nico cuando sea posible.
          </p>

          <div class="cr-generator__warning">
            <strong>Disclaimer:</strong> Este generador no sustituye asesoramiento legal
            profesional. Revisa siempre los datos antes de enviar.
          </div>
        </div>

        {/* Columna derecha: previsualizaci칩n */}
        <div class="cr-generator__preview">
          <div class="cr-generator__preview-header">
            <h2 class="cr-generator__preview-title">Previsualizaci칩n</h2>
            <div class="cr-generator__preview-actions">
              <button class="cr-button cr-button--ghost" data-cr-copy>
                Copiar
              </button>
              <button class="cr-button cr-button--primary" data-cr-pdf>
                Descargar PDF
              </button>
            </div>
          </div>
          <pre class="cr-generator__preview-body" data-cr-preview></pre>
        </div>
      </div>
    </div>

    {/* Script de cliente: l칩gica del generador */}
    <script define:vars={{ cartas, initialCartaId, showSelect }}>
      /** @typedef {{ name: string; label: string }} FieldDef */
      /** @typedef {{ id: string; titulo: string; body: string; fields: FieldDef[]; hasFirma: boolean }} CartaDef */

      /** @type {CartaDef[]} */
      const allCartas = cartas;
      const defaultCartaId = initialCartaId;
      const enableSelect = showSelect;

      const root = document.querySelector('[data-cr-generator]');
      if (!root || !allCartas.length) {
        console.warn('Cartas R치pidas: no se ha encontrado el contenedor del generador.');
      } else {
        const select = root.querySelector('select[data-cr-template]');
        const fieldsContainer = root.querySelector('[data-cr-fields]');
        const previewEl = root.querySelector('[data-cr-preview]');
        const generateBtn = root.querySelector('[data-cr-generate]');
        const resetBtn = root.querySelector('[data-cr-reset]');
        const copyBtn = root.querySelector('[data-cr-copy]');
        const pdfBtn = root.querySelector('[data-cr-pdf]');

        const signatureSection = root.querySelector('[data-cr-signature]');
        const signatureCanvas = signatureSection?.querySelector('canvas');
        const signatureClearBtn = signatureSection?.querySelector('[data-cr-signature-clear]');

        const cartasById = new Map(allCartas.map((carta) => [carta.id, carta]));
        /** @type {CartaDef} */
        let currentCarta = cartasById.get(defaultCartaId) || allCartas[0];

        /** @type {Record<string, string>} */
        let formState = {};

        // --- Firma (canvas) ---
        /** @type {CanvasRenderingContext2D | null} */
        let signatureCtx = null;
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let signatureDataUrl = '';

        function setupSignaturePad() {
          if (!signatureCanvas) return;
          const ctx = signatureCanvas.getContext('2d');
          if (!ctx) return;
          signatureCtx = ctx;
          ctx.lineWidth = 2;
          ctx.lineCap = 'round';
          ctx.strokeStyle = '#111827';

          const getPos = (evt) => {
            const rect = signatureCanvas.getBoundingClientRect();
            return {
              x: evt.clientX - rect.left,
              y: evt.clientY - rect.top,
            };
          };

          const start = (evt) => {
            evt.preventDefault();
            const pos = getPos(evt);
            isDrawing = true;
            lastX = pos.x;
            lastY = pos.y;
          };

          const draw = (evt) => {
            if (!isDrawing || !signatureCtx) return;
            evt.preventDefault();
            const pos = getPos(evt);
            signatureCtx.beginPath();
            signatureCtx.moveTo(lastX, lastY);
            signatureCtx.lineTo(pos.x, pos.y);
            signatureCtx.stroke();
            lastX = pos.x;
            lastY = pos.y;
          };

          const stop = (evt) => {
            evt?.preventDefault();
            if (isDrawing && signatureCanvas) {
              // Guardamos la firma como dataURL para poder mostrarla en la previsualizaci칩n
              signatureDataUrl = signatureCanvas.toDataURL('image/png');
              updatePreview();
            }
            isDrawing = false;
          };

          signatureCanvas.addEventListener('pointerdown', start);
          signatureCanvas.addEventListener('pointermove', draw);
          ['pointerup', 'pointerleave', 'pointercancel'].forEach((type) =>
            signatureCanvas.addEventListener(type, stop)
          );

          signatureCanvas.style.touchAction = 'none';
        }

        function clearSignatureCanvas() {
          if (!signatureCtx || !signatureCanvas) return;
          signatureCtx.clearRect(0, 0, signatureCanvas.width, signatureCanvas.height);
          signatureDataUrl = '';
          updatePreview();
        }

        function updateSignatureVisibility() {
          if (!signatureSection) return;
          if (currentCarta && currentCarta.hasFirma) {
            signatureSection.hidden = false;
          } else {
            signatureSection.hidden = true;
            clearSignatureCanvas();
          }
        }

        // --- Helpers para texto / Markdown / HTML ---

        // Peque침o formateador Markdown (negrita y cursiva b치sicas)
        function applyMarkdownFormatting(text) {
          if (!text) return '';
          // Negrita: **texto**
          text = text.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
          // Cursiva: _texto_ o *texto*
          text = text.replace(/_(.+?)_/g, '<em>$1</em>');
          text = text.replace(/\*(.+?)\*/g, '<em>$1</em>');
          return text;
        }

        // Base: carta con placeholders (excepto {firma}) resueltos
        function buildBaseText() {
          if (!currentCarta) return '';

          // Si todos los campos est치n vac칤os, no mostramos nada
          const hasAnyValue = Object.values(formState).some(
            (v) => v && v.trim() !== ''
          );
          if (!hasAnyValue) return '';

          let text = currentCarta.body;

          for (const [name, value] of Object.entries(formState)) {
            const pattern = new RegExp('\\{' + name + '\\}', 'g');
            text = text.replace(pattern, value || '{' + name + '}');
          }

          return text;
        }

        // Versi칩n texto plano (para copiar / PDF)
        function buildPreviewText() {
          let text = buildBaseText();
          if (!text) return '';

          // Para texto plano, eliminamos marcadores Markdown
          text = text.replace(/\*\*(.+?)\*\*/g, '$1');
          text = text.replace(/_(.+?)_/g, '$1');
          text = text.replace(/\*(.+?)\*/g, '$1');

          if (currentCarta.hasFirma) {
            text = text.replace(/\{firma\}/g, '\n\n\n');
          }

          return text;
        }

        // Versi칩n HTML (para la previsualizaci칩n con imagen)
        function buildPreviewHtml() {
          let text = buildBaseText();
          if (!text) return '';

          // Token que no contiene ni * ni _ para que el parser de Markdown NO lo toque
          const FIRMA_TOKEN = 'CRFIRMATOKENPLACEHOLDER';

          if (currentCarta.hasFirma) {
            // Sustituimos {firma} por el token temporal
            text = text.replace(/\{firma\}/g, FIRMA_TOKEN);
          }

          // Aplicamos Markdown b치sico
          text = applyMarkdownFormatting(text);

          if (currentCarta.hasFirma) {
            const firmaHtml = signatureDataUrl
              ? `<div class="cr-preview-signature"><img src="${signatureDataUrl}" alt="Firma" /></div>`
              : '<br><br><br>';

            // Reemplazamos TODAS las apariciones del token por la firma (o por espacio en blanco)
            text = text.split(FIRMA_TOKEN).join(firmaHtml);
          }

          // Saltos de l칤nea -> <br>
          text = text.replace(/\n/g, '<br />');

          return text;
        }

        function updatePreview() {
          if (!previewEl) return;
          const html = buildPreviewHtml();
          previewEl.innerHTML = html;
        }

        // --- Campos y select ---

        function setupSelect() {
          if (!select) return;
          if (!enableSelect) {
            // No rellenamos nada: el selector puede ocultarse por CSS
            return;
          }

          select.innerHTML = '';
          allCartas.forEach((carta) => {
            const option = document.createElement('option');
            option.value = carta.id;
            option.textContent = carta.titulo;
            if (carta.id === currentCarta.id) option.selected = true;
            select.appendChild(option);
          });

          select.addEventListener('change', () => {
            const selected = cartasById.get(select.value);
            if (!selected) return;
            currentCarta = selected;
            renderFields();
            updateSignatureVisibility();
            updatePreview();
          });
        }

        function renderFields() {
          if (!fieldsContainer) return;
          fieldsContainer.innerHTML = '';
          formState = {};

          currentCarta.fields.forEach((field) => {
            formState[field.name] = '';

            const fieldWrapper = document.createElement('div');
            fieldWrapper.className = 'cr-field';

            fieldWrapper.innerHTML = `
              <label class="cr-field__label">
                <span>${field.label}</span>
                <input class="cr-field__input" name="${field.name}" autocomplete="off" />
              </label>
            `;

            const input = fieldWrapper.querySelector('input');
            if (!input) return;

            input.addEventListener('input', () => {
              formState[field.name] = input.value;
              updatePreview(); // actualizaci칩n autom치tica
            });

            fieldsContainer.appendChild(fieldWrapper);
          });
        }

        // --- Acciones ---

        function handleReset() {
          renderFields();
          clearSignatureCanvas();
          updatePreview();
        }

        function handleGenerate(evt) {
          evt?.preventDefault();
          updatePreview();
        }

        function handleCopy(evt) {
          evt?.preventDefault();
          const text = buildPreviewText();
          if (navigator.clipboard && text) {
            navigator.clipboard.writeText(text).catch(() => {
              console.warn('No se pudo copiar al portapapeles.');
            });
          }
        }

        function handlePdf(evt) {
          evt?.preventDefault();

          // Usamos el texto base con {firma} dentro
          let baseText = buildBaseText();
          if (!baseText) {
            alert('Rellena la carta antes de descargar el PDF.');
            return;
          }

          // Quitamos los marcadores Markdown para el PDF
          baseText = baseText
            .replace(/\*\*(.+?)\*\*/g, '$1')
            .replace(/_(.+?)_/g, '$1')
            .replace(/\*(.+?)\*/g, '$1');

          // Por defecto: todo el texto antes, nada despu칠s
          let beforeText = baseText;
          let afterText = '';

          // Si la carta tiene marcador {firma}, lo usamos para partir el texto
          if (currentCarta.hasFirma) {
            const parts = baseText.split(/\{firma\}/g);

            if (parts.length > 1) {
              beforeText = parts[0] || '';
              // Si hubiera m치s de un {firma}, juntamos el resto por si acaso
              afterText = parts.slice(1).join('\n\n');
            }
          }

          if (
            !window.CartasRapidas ||
            typeof window.CartasRapidas.generateLetterPdf !== 'function'
          ) {
            alert('No se ha podido cargar el generador de PDF. Intenta recargar la p치gina.');
            return;
          }

          window.CartasRapidas.generateLetterPdf({
            beforeText,
            afterText,
            signatureDataUrl: currentCarta.hasFirma ? signatureDataUrl : '',
            title: currentCarta?.titulo || 'carta',
          });
        }

        // Eventos
        generateBtn?.addEventListener('click', handleGenerate);
        resetBtn?.addEventListener('click', (evt) => {
          evt.preventDefault();
          handleReset();
        });
        copyBtn?.addEventListener('click', handleCopy);
        pdfBtn?.addEventListener('click', handlePdf);
        signatureClearBtn?.addEventListener('click', (evt) => {
          evt.preventDefault();
          clearSignatureCanvas();
        });

        // Inicializaci칩n
        setupSignaturePad();
        setupSelect();
        renderFields();
        updateSignatureVisibility();
        updatePreview();
      }
    </script>

    <script type="module" src="/src/lib/pdf-client.js"></script>
  </section>
)}
